# -*- coding: utf-8 -*-
import random as rd

#  Названия переменных должны быть записаны строчными буквами.
g_mind_number = ''


def check(nnumb):
    lsnumb = list(str(nnumb))
    mslsnumb = set(lsnumb)
    if len(lsnumb) == len(mslsnumb):
        return True
    else:
        return False


#  Не самый оптимальный способ генерации числа.
#  В библиотеке random есть более подходящие функции.
#  Например shuffle или sample. С sample можно получить
#  сразу всю случайную последовательность одной командой.
#  Если хотите избегать 0 на первой позиции,
#  то генерировать последовательлность можно в цикле,
#  пока не получится последовательность начинающуася не с 0.
#  Или можно вместо последовательности в 4 символа сгенерировать 5
#  И если на первой позиции 0 сделать срез списка [1:], если не 0 [:4]
#  Функция shuffle позволяет перемешать элементы списка,
#  который можно сделать как list(range(10)). Останется только проверить
#  0 элемент и использовать срез.
def make_number():
    res = 0
    numbers = [str(i) for i in range(0, 10)]
    while str(res)[0:1] == '0' and len(str(res)) != 4:
        res = int(''.join(rd.sample(numbers, 4)))
    global g_mind_number
    g_mind_number = str(res)


def check_user_number(sumb):
    # Названия переменных должны быть записаны строчными буквами.
    user_number: int = 0
    lsumb = list(sumb)
    if len(sumb) != 4:
        return 'Число должно быть из 4 цифр', user_number
    elif lsumb[0] == '0':
        return 'Первая цифра не может быть 0', user_number
    elif len(lsumb) != len(set(lsumb)):
        return 'Все цифры в числе должны быть разные', user_number
    else:
        user_number = sumb
        return "ok", user_number


def play(user_number):
    #  возможно с использованием range или enumerate. В цикле нужно сделать две проверки:
    #  - сначала найти быка, через == проверить что цифра на i-й позиции совпадает
    #  - если число не бык, то оператором in проверить есть ли цифра в другом списке.
    #  Если есть, то это корова. Можно не хранить числа, являющиеся быками или коровами
    #  а только количество быков или коров, установленное в ходе проверок.
    # - Я не очень понимаю предложенный вами алгоритм.
    #  Названия переменных должны быть записаны строчными буквами.
    #  Нет необходимости преобразовывать user_number в список символов.
    #  Цикл можно сделать и по строке.
    #  Загаданное число можно сразу преобразовать в строку, и не делать
    #  это преобразование при каждой проверке числа, введённого пользователем.
    bulls = 0
    cows = 0
    for i, val in enumerate(g_mind_number):
        if user_number[i] == g_mind_number[i]:
            bulls += 1
        elif user_number[i] in list(g_mind_number):
            cows += 1
    return {'bulls': bulls, 'cows': cows}


def play_work(user_number):
    #  Для того, чтобы посчитать быков и коров достаточно одного цикла,
    # - А где тут больше 1 цикла? Операции над множествами
    #     позволяют достачно в комактной форме получить результат
    #  Код в функции play проще для понимания и должен работать немного быстрее.

    bulls = set()
    # Названия переменных должны быть записаны строчными буквами.
    set_user_numb = set(list(str(user_number)))
    for i in range(0, 4):
        if str(user_number)[i] == str(g_mind_number)[i]:
            bulls.add(str(user_number)[i])
    not_bulls = set(list(str(g_mind_number))) - bulls
    cows = not_bulls & set_user_numb
    return {'bulls': len(bulls), 'cows': len(cows)}


print(make_number())

#  Обращайте внимание на предупреждения среды разработки о
#  проблемах в коде или нарушении стандарта PEP 8.
#  Попробуйте найти зеленую галочку справа над полосой прокрутки.
#  Если вместо нее, квадрат красного, желтого или серого цвета,
#  значит в файле есть недостатки оформления или ошибки.
#  Места с ошибками помечены цветными отметками на полосе прокрутки.
