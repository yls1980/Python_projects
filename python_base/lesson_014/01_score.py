# -*- coding: utf-8 -*-
import random

#from lesson_014.bowling import Bowling
from bowling import Inlocal
import argparse


# Вас взяли на работу в молодой стартап. Идея стартапа - предоставлять сервис расчета результатов игр.
# Начать решили с боулинга, упрощенной версии.
#
# Правила такие.
#
# Всего 10 кеглей. Игра состоит из 10 фреймов. В одном фрейме до 2х бросков, цель - сбить все кегли.
# Результаты фрейма записываются символами:
#   «Х» – «strike», все 10 кеглей сбиты первым броском
#   «<число>/», например «4/» - «spare», в первый бросок сбиты 4 кегли, во второй – остальные
#   «<число><число>», например, «34» – в первый бросок сбито 3, во второй – 4 кегли.
#   вместо <число> может стоять прочерк «-», например «-4» - ни одной кегли не было сбито за первый бросок
# Результат игры – строка с записью результатов фреймов. Символов-разделителей между фреймами нет.
# Например, для игры из 4 фреймов запись результатов может выглядеть так:
#   «Х4/34-4»
# Предлагается упрощенный способ подсчета количества очков:
#   «Х» – strike всегда 20 очков
#   «4/» - spare всегда 15 очков
#   «34» – сумма 3+4=7
#   «-4» - сумма 0+4=4
# То есть для игры «Х4/34-4» сумма очков равна 20+15+7+4=46
#
# Надо написать python-модуль (назвать bowling), предоставляющий API расчета количества очков:
# функцию get_score, принимающую параметр game_result. Функция должна выбрасывать исключения,
# когда game_result содержит некорректные данные. Использовать стандартные исключения по максимуму,
# если не хватает - создать свои.
#
# Обязательно написать тесты на этот модуль. Расположить в папке tests.

# Из текущего файла сделать консольную утилиту для определения количества очков, с помощью пакета argparse
# Скрипт должен принимать параметр --result и печатать на консоль:
#   Количество очков для результатов ХХХ - УУУ.

#  тут ваш код
# Здравствуйте, что такое фрейм? Можно поподробнее описать процесс игры?
#  Фрейм это минмально учитываемый эпизод игры, за кторый игрок может
#  сбить 10 кеглей. Если он сбивает все кегли за один бросок, то такая
#  ситуация называется strike (страйк) и записывается как "X". Если сбиты не все кегли,
#  то записывается количество сбитых от 1 до 9. Если не сбито ни одной, то
#  ставится "-". Если на втором броске сбиты оставшиеся кегли, то такая
#  игровая ситуация называется spare (спэир) и записывается как 1/, 2/, ..., 9/.
#  Если сбиты не все то записывается число или "-". В первом задании нужно
#  реализовать упрощенные правила подсчёта очков, которые записаны выше.
#  Вам нужно реализовать класс, в который будет передаваться строка с результатом
#  игры. В ответ нужно возвращать количество очков.


#  В этом модуле нужно сделать только парсер аргументов командной строки.
#  При подсчёте очков нужно проверять возможные ошибочные ситуации.
#  Например сейчас можно записать 20 фреймов со страйками, символ /
#  может оказаться на первой позиции или сумма сбытых кеглей
#  может быть больше 10.

#- Количество фреймов должно быть равно 10. Сейчас проверяется длина строки, так что можно передеть от 5 до 20 фреймов.
# Символ X, обозначающий страйк занимает один символ. Остальные типы фреймов записываются двумя символами. Так что нужно считать именно количество фреймов.
#- Символ / используется при записи спэиров (spare). Этот символ не может встречаться первым символом фрейма.
#- Количество сбитых в фрейме кеглей не может быть больше 10. Десять сбитых кеглей могут быть только если записан страйк или спэир.
#Нужно определять ошибочные ситуации и выбрасывать исключения с описанием ошибки.

def parser_sets():
    pars = argparse.ArgumentParser(description='Calc bowling Result')
    pars.add_argument('result', type=str, help='Input game result')
    return pars.parse_args()


if __name__ == "__main__":
    args = parser_sets()
    #test_run()
    score = Inlocal(args.result).get_score()
    print(f" Количество очков для результатов {args.result} - {score}")


# При написании кода помнить, что заказчик может захотеть доработок и новых возможностей...
# И, возможно, вам пригодится паттерн проектирования "Состояние",
#   см https://clck.ru/Fudd8 и https://refactoring.guru/ru/design-patterns/state

# Зачёт!
